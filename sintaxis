Programa = functions:(_ DeclaracionDeFuncion _)*
   { return {
       node: "Program",
       functions: functions.map(function(f) { return f[1]; })
     };
   }

DeclaracionDeFuncion = DeclaracionDeFuncionConTipos / DeclaracionDeFuncionSinTipos
DeclaracionDeFuncionConTipos = FUN _ id:ID _ params:Parametros _ COLON _ type:Tipo _ block:Bloque
   { return { node: "Function", id: id, params: params, type: type, block: block }; }
DeclaracionDeFuncionSinTipos = FUN _ id:ID _ params:Parametros _ block:Bloque
   { return { node: "Function", id: id, params: params, type: "Unit", block: block }; }

Parametros = LPAREN _ list:ListaParametros _ RPAREN
   { return list; }
ListaParametros = first:Parametro? rest:(_ COMMA _ Parametro)*
   { if(first) { return [first].concat(rest); } else { return []; } }

Parametro = id:ID _ COLON _ type:Tipo
   { return { node: "Parameter", id: id, type: type }; }

Tipo =
   INT  { return "Int"; }
 / BOOL { return "Bool"; }
 / VEC  { return "Vec"; }

Bloque = LBRACE _ instructions:ListaDeInstrucciones _ RBRACE
   { return { node: "Block", instructions: instructions }; }

ListaDeInstrucciones = instrs:(_ Instruccion _)*
   { return instrs.map(function(i){ return i[1]; } ); }

Instruccion =
   id:ID _ ASSIGN _ expr:Expresion
   { return { node: "StmtAssign", id: id, expr: expr }; }
 / id:ID _ LBRACK _ expr1:Expresion _ RBRACK _ ASSIGN _ expr2:Expresion
   { return { node: "StmtVecAssign", id: id, expr1: expr1, expr2: expr2 }; }
 / IF _ expr:Expresion _ block1:Bloque _ ELSE _ block2:Bloque
   { return { node: "StmtIfElse", expr: expr, block1: block1, block2: block2 }; }
 / IF _ expr:Expresion _ block:Bloque
   { return { node: "StmtIf", expr: expr, block: block }; }
 / WHILE _ expr:Expresion _ block:Bloque
   { return { node: "StmtWhile", expr: expr, block: block }; }
 / RETURN _ expr:Expresion
   { return { node: "StmtReturn", expr: expr }; }
 / id:ID LPAREN expressions:ListaDeExpresiones RPAREN
   { return { node: "StmtCall", expressions: expressions }; }

ListaDeExpresiones = first:Expresion? rest:(_ COMMA _ Expresion)*
   { if(first) { return [first].concat(rest); } else { return []; } }

Expresion = ExpresionLogica

ExpresionLogica =
  ExpresionLogicaAtomica
  (
    (_ AND _ ExpresionLogicaAtomica) /
    (_ OR _ ExpresionLogicaAtomica)
  )*

ExpresionLogicaAtomica = (NOT _ ExpresionLogicaAtomica) / ExpresionRelacional

ExpresionRelacional = (ExpresionAditiva _ LE _ ExpresionAditiva)
 / (ExpresionAditiva _ GE _ ExpresionAditiva)
 / (ExpresionAditiva _ LT _ ExpresionAditiva)
 / (ExpresionAditiva _ GT _ ExpresionAditiva)
 / (ExpresionAditiva _ EQ _ ExpresionAditiva)
 / (ExpresionAditiva _ NE _ ExpresionAditiva)
 / ExpresionAditiva

ExpresionAditiva =
  ExpresionMultiplicativa
  (
    (_ PLUS _ ExpresionMultiplicativa) /
    (_ MINUS _ ExpresionMultiplicativa)
  )*

ExpresionMultiplicativa = ExpresionAtomica (_ TIMES _ ExpresionAtomica)*

ExpresionAtomica =
   LBRACK ListaDeExpresiones RBRACK
 / HASH ID
 / id:ID LPAREN exprList:ListaDeExpresiones RPAREN
   { return { node: "ExprCall", id: id, exprList: exprList }; }
 / id:ID LBRACK expr:Expresion RBRACK
   { return { node: "ExprVecDeref", id: id, expr: expr }; }
 / LPAREN expr:Expresion RPAREN
   { return expr; }
 / NUM
   { return { node: "ExprConstNum", value: parseInt(text()) }; }
 / TRUE
   { return { node: "ExprConstBool", value: true }; }
 / FALSE
   { return { node: "ExprConstBool", value: false }; }
 / ID
   { return { node: "ExprVar", value: text() }; }

ID = [a-zA-Z][a-zA-Z0-9]* { return text(); }
NUM = [0-9]+

LPAREN = "("
RPAREN = ")"
COMMA = ","
LBRACK = "["
RBRACK = "]"
LBRACE = "{"
RBRACE = "}"
ASSIGN = ":="
COLON = ":"
HASH = "#"
LE = "<="
GE = ">="
LT = "<"
GT = ">"
EQ = "=="
NE = "!="
PLUS = "+"
MINUS = "-"
TIMES = "*"

BOOL = "Bool"
INT = "Int"
VEC = "Vec"
TRUE = "True"
FALSE = "False"
AND = "and"
ELSE = "else"
FUN = "fun"
IF = "if"
NOT = "not"
OR = "or"
RETURN = "return"
WHILE = "while"

_ = (Whitespace / Comment)*

Whitespace = [ \t\n\r]
Comment = "//"[^\n\r]*
