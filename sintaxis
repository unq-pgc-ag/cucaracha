{
  function startIdent(node, ident) {
    return ident + "(" + node + "\n";
  }

  function identBinaryExpr(ident, newIdent, node, expr1, expr2) {
    return startIdent(node, ident)
       + expr1.serialize(newIdent)
       + expr2.serialize(newIdent)
       + ident + ")\n";
  }

  function identId(id, newIdent, lastIdent) {
    return newIdent + id + "\n" + lastIdent;
  }

  function lastIdent(ident) {
    return ident + ")\n";
  }

  function serializeList(list, ident) {
    return list.map(function(e) { return e.serialize(ident); }).join('');
  }
}

Programa = functions:(_ DeclaracionDeFuncion _)*
   { return {
       node: "Program",
       functions: functions.map(function(f) { return f[1]; }),
       serialize: function () {
         var hijos = serializeList(this.functions, "  ");
         return startIdent(this.node, "") + hijos + ")\n";
       },
       estaBienFormado: function() {
         var funcionesBienFormadas = this.functions.reduce(function(res, f){ return res && f.estaBienFormado() }, true);
         var nombresDeFunciones = this.functions.map(function(f) { return f.id; });
         var redefinePutChar = nombresDeFunciones.indexOf("putChar") != -1;
         var redefinePutNum = nombresDeFunciones.indexOf("putNum") != -1;
         var funcionesNoRepetidas = this.functions.reduce(function(res, f){
           var index = nombresDeFunciones.indexOf(f.id);
           nombresDeFunciones.splice(index, 1);
           return res && nombresDeFunciones.indexOf(f.id) == -1
         }, true);
         var listaDeMains = this.functions.filter(function(f) { return f.id == "main" });
         var main = listaDeMains[0];
         var verificarMain = listaDeMains.length == 1 && main && main.tipo == "Unit";
         return funcionesNoRepetidas && funcionesBienFormadas && verificarMain && !redefinePutChar && !redefinePutNum;
       }
     };
   }

DeclaracionDeFuncion = DeclaracionDeFuncionConTipos / DeclaracionDeFuncionSinTipos
DeclaracionDeFuncionConTipos = FUN _ id:ID _ params:Parametros _ COLON _ tipo:Tipo _ block:Bloque
   { return {
       node: "Function",
       id: id,
       params: params,
       tipo: tipo,
       block: block,
       serialize: function(ident) {
         var newIdent = ident + "  ";
         var params = serializeList(this.params, newIdent);
         return startIdent(this.node, ident)
           + identId(this.id, newIdent, newIdent)
           + this.tipo + "\n"
           + params
           + this.block.serialize(newIdent)
           + lastIdent(ident);
       },
       estaBienFormado: function() {
        return tipo != "Vec";
      }
     };
   }
DeclaracionDeFuncionSinTipos = FUN _ id:ID _ params:Parametros _ block:Bloque
   { return {
       node: "Function",
       id: id,
       params: params,
       tipo: "Unit",
       block: block,
       serialize: function(ident) {
         var newIdent = ident + "  ";
         var params = serializeList(this.params, newIdent);
         return startIdent(this.node, ident)
           + identId(this.id, newIdent, newIdent)
           + this.tipo + "\n"
           + params
           + this.block.serialize(newIdent)
           + lastIdent(ident);
       },
       estaBienFormado: function() {
        return true;
      }
     };
   }

Parametros = LPAREN _ list:ListaParametros _ RPAREN
   { return list; }
ListaParametros = first:Parametro? rest:(_ COMMA _ Parametro)*
   { if(first) {
       return [first].concat(rest.map(function (r) { return r[3]; }));
     } else {
       return [];
     }
   }

Parametro = id:ID _ COLON _ type:Tipo
   { return {
       node: "Parameter", id: id, type: type,
       serialize: function(ident) {
         var newIdent = ident + "  ";
         return startIdent(this.node, ident)
           + identId(this.id, newIdent, newIdent)
           + this.type + "\n" + lastIdent(ident);
       }
     };
   }

Tipo =
   INT  { return "Int"; }
 / BOOL { return "Bool"; }
 / VEC  { return "Vec"; }

Bloque = LBRACE _ instructions:ListaDeInstrucciones _ RBRACE
   { return {
       node: "Block",
       instructions: instructions,
       serialize: function(ident) {
         var newIdent = ident + "  ";
         var instructions = serializeList(this.instructions, newIdent);
         return startIdent(this.node, ident)
           + instructions + lastIdent(ident);
       }
     };
   }

ListaDeInstrucciones = instrs:(_ Instruccion _)*
   { return instrs.map(function(i){ return i[1]; } ); }

Instruccion =
   id:ID _ ASSIGN _ expr:Expresion
   { return {
       node: "StmtAssign", id: id, expr: expr,
       serialize: function(ident) {
         var newIdent = ident + "  ";
         return startIdent(this.node, ident)
           + identId(this.id, newIdent, "")
           + this.expr.serialize(newIdent)
           + lastIdent(ident);
       }
     };
   }

 / id:ID _ LBRACK _ expr1:Expresion _ RBRACK _ ASSIGN _ expr2:Expresion
   { return {
       node: "StmtVecAssign", id: id, expr1: expr1, expr2: expr2,
       serialize: function(ident) {
         var newIdent = ident + "  ";
         return startIdent(this.node, ident)
           + identId(this.id, newIdent, "")
           + this.expr1.serialize(newIdent)
           + this.expr2.serialize(newIdent)
           + lastIdent(ident);
       }
     };
   }

 / IF _ expr:Expresion _ block1:Bloque _ ELSE _ block2:Bloque
   { return {
       node: "StmtIfElse", expr: expr, block1: block1, block2: block2,
       serialize: function(ident) {
         var newIdent = ident + "  ";
         return startIdent(this.node, ident)
                    + this.expr.serialize(newIdent)
                    + this.block1.serialize(newIdent)
                    + this.block2.serialize(newIdent)
                    + lastIdent(ident);
       }
     };
   }

 / IF _ expr:Expresion _ block:Bloque
   { return {
       node: "StmtIf", expr: expr, block: block,
       serialize: function(ident) {
         var newIdent = ident + "  ";
         return startIdent(this.node, ident)
                             + this.expr.serialize(newIdent)
                             + this.block.serialize(newIdent)
                             + lastIdent(ident);
       }
     };
   }

 / WHILE _ expr:Expresion _ block:Bloque
   { return {
       node: "StmtWhile", expr: expr, block: block,
       serialize: function(ident) {
         var newIdent = ident + "  ";
          return startIdent(this.node, ident)
            + this.expr.serialize(newIdent)
            + this.block.serialize(newIdent)
            + lastIdent(ident);
       }
     };
   }

 / RETURN _ expr:Expresion
   { return {
       node: "StmtReturn", expr: expr,
       serialize: function(ident) {
         var newIdent = ident + "  ";
         return startIdent(this.node, ident)
             + this.expr.serialize(newIdent)
             + lastIdent(ident);
       }
     };
   }

 / id:ID LPAREN expressions:ListaDeExpresiones RPAREN
   { return {
       node: "StmtCall", id: id, expressions: expressions,
       serialize: function(ident) {
         var newIdent = ident + "  ";
         var params = serializeList(this.expressions, newIdent);
         return startIdent(this.node, ident)
           + identId(this.id, newIdent, "")
           + params
           + lastIdent(ident);
       }
     };
   }

ListaDeExpresiones = first:Expresion? rest:(_ COMMA _ Expresion)*
   { if(first) {
       return [first].concat(rest.map(function (r) { return r[3]; }));
     } else {
       return [];
     }
   }

Expresion = ExpresionLogica

ExpresionLogica = expr:ExpresionLogicaAtomica
   rest:((_ AND _ ExpresionLogicaAtomica) / (_ OR _ ExpresionLogicaAtomica))*
   { if (rest.length > 0) {
       return rest.reduce(function(acc, curr) {
         return {
           node: curr[1] == "and" ? "ExprAnd" : "ExprOr",
           expr1: acc,
           expr2: curr[3],
           serialize: function(ident) {
             var newIdent = ident + "  ";
             return identBinaryExpr(ident, newIdent, this.node, this.expr1, this.expr2);
           }
         }
       }, expr);
     } else {
       return expr;
     }
   }

ExpresionLogicaAtomica = Negacion / ExpresionRelacional
Negacion = NOT _ expr:ExpresionLogicaAtomica
   { return {
       node: "ExprNot", expr: expr,
       serialize: function(ident) {
        var newIdent = ident + "  ";
         return startIdent(this.node, ident)
           + this.expr.serialize(newIdent)
           + lastIdent(ident);
      }
     };
   }

ExpresionRelacional =
   expr1:ExpresionAditiva _ LE _ expr2:ExpresionAditiva
   { return {
     node: "ExprLe", expr1: expr1, expr2: expr2,
      serialize: function(ident) {
       var newIdent = ident + "  ";
        return identBinaryExpr(ident, newIdent, this.node, this.expr1, this.expr2);
      }
     };
   }
 / expr1:ExpresionAditiva _ GE _ expr2:ExpresionAditiva
   { return {
   node: "ExprGe", expr1: expr1, expr2: expr2,
    serialize: function(ident) {
     var newIdent = ident + "  ";
      return identBinaryExpr(ident, newIdent, this.node, this.expr1, this.expr2);
   }};
   }
 / expr1:ExpresionAditiva _ LT _ expr2:ExpresionAditiva
   { return {
   node: "ExprLt", expr1: expr1, expr2: expr2,
    serialize: function(ident) {
     var newIdent = ident + "  ";
      return identBinaryExpr(ident, newIdent, this.node, this.expr1, this.expr2);
   }};
   }
 / expr1:ExpresionAditiva _ GT _ expr2:ExpresionAditiva
   { return {
   node: "ExprGt", expr1: expr1, expr2: expr2,
    serialize: function(ident) {
     var newIdent = ident + "  ";
      return identBinaryExpr(ident, newIdent, this.node, this.expr1, this.expr2);
   }};
   }
 / expr1:ExpresionAditiva _ EQ _ expr2:ExpresionAditiva
   { return {
   node: "ExprEq", expr1: expr1, expr2: expr2,
    serialize: function(ident) {
     var newIdent = ident + "  ";
      return identBinaryExpr(ident, newIdent, this.node, this.expr1, this.expr2);
   }};
   }
 / expr1:ExpresionAditiva _ NE _ expr2:ExpresionAditiva
   { return {
   node: "ExprNe", expr1: expr1, expr2: expr2,
    serialize: function(ident) {
     var newIdent = ident + "  ";
      return identBinaryExpr(ident, newIdent, this.node, this.expr1, this.expr2);
   }};
   }
 / ExpresionAditiva

ExpresionAditiva = expr:ExpresionMultiplicativa
   rest:((_ PLUS _ ExpresionMultiplicativa) / (_ MINUS _ ExpresionMultiplicativa))*
   { if (rest.length > 0) {
       return rest.reduce(function(acc, curr) {
         return {
           node: curr[1] == "+" ? "ExprAdd" : "ExprSub",
           expr1: acc,
           expr2: curr[3],
           serialize: function(ident) {
            var newIdent = ident + "  ";
             return identBinaryExpr(ident, newIdent, this.node, this.expr1, this.expr2);
          }
         }
       }, expr);
     } else {
       return expr;
     }
   }

ExpresionMultiplicativa = expr:ExpresionAtomica rest:(_ TIMES _ ExpresionAtomica)*
   { if (rest.length > 0) {
       return rest.reduce(function(acc, curr) {
         return {
           node: "ExprMul",
           expr1: acc,
           expr2: curr[3],
           serialize: function(ident) {
            var newIdent = ident + "  ";
             return identBinaryExpr(ident, newIdent, this.node, this.expr1, this.expr2);
          }
         }
       }, expr);
     } else {
       return expr;
     }
   }

ExpresionAtomica =
   LBRACK exprs:ListaDeExpresiones RBRACK
   { return {
       node: "ExprVecMake", exprs:exprs,
       serialize: function(ident) {
         var newIdent = ident + "  ";
         var params = serializeList(this.exprs, newIdent);
          return startIdent(this.node, ident)
            + params
            + lastIdent(ident);
       }
     };
   }
 / HASH id:ID
   { return {
      node: "ExprVecLength", id: id,
      serialize: function(ident) {
        var newIdent = ident + "  ";
        return startIdent(this.node, ident)
         + identId(this.id, newIdent, "")
         + lastIdent(ident);
      }
    };
   }
 / id:ID LPAREN exprList:ListaDeExpresiones RPAREN
    { return {
       node: "ExprCall", id: id, exprList: exprList,
       serialize: function(ident) {
         var newIdent = ident + "  ";
         var params = serializeList(this.exprList, newIdent);
           return startIdent(this.node, ident)
             + identId(this.id, newIdent, "")
             + params
             + lastIdent(ident);
       }
     };
    }
 / id:ID LBRACK expr:Expresion RBRACK
   { return {
      node: "ExprVecDeref", id: id, expr: expr,
      serialize: function(ident) {
        var newIdent = ident + "  ";
        return startIdent(this.node, ident)
           + identId(this.id, newIdent, "")
           + this.expr.serialize(newIdent)
           + lastIdent(ident);
      }
    };
   }
 / LPAREN expr:Expresion RPAREN
   { return expr; }
 / NUM
   { return {
     node: "ExprConstNum", value: text(),
     serialize: function(ident) {
       var newIdent = ident + "  ";
       return startIdent(this.node, ident)
       + identId(this.value, newIdent, "")
       + lastIdent(ident);
     }
   };
  }
 / TRUE
   { return {
     node: "ExprConstBool", value: "True",
     serialize: function(ident) {
       var newIdent = ident + "  ";
       return startIdent(this.node, ident)
        + identId(this.value, newIdent, "")
        + lastIdent(ident);
     }
   };
  }
 / FALSE
   { return {
     node: "ExprConstBool", value: "False",
     serialize: function(ident) {
       var newIdent = ident + "  ";
       return startIdent(this.node, ident)
        + identId(this.value, newIdent, "")
        + lastIdent(ident);
     }
   };
  }
 / ID
   { return {
     node: "ExprVar", value: text(),
     serialize: function(ident) {
       var newIdent = ident + "  ";
       return startIdent(this.node, ident)
         + identId(this.value, newIdent, "")
         + lastIdent(ident);
     }
   };
  }

ID = [a-zA-Z][a-zA-Z0-9]* { return text(); }
NUM = [0-9]+

LPAREN = "("
RPAREN = ")"
COMMA = ","
LBRACK = "["
RBRACK = "]"
LBRACE = "{"
RBRACE = "}"
ASSIGN = ":="
COLON = ":"
HASH = "#"
LE = "<="
GE = ">="
LT = "<"
GT = ">"
EQ = "=="
NE = "!="
PLUS = "+"
MINUS = "-"
TIMES = "*"

BOOL = "Bool"
INT = "Int"
VEC = "Vec"
TRUE = "True"
FALSE = "False"
AND = "and"
ELSE = "else"
FUN = "fun"
IF = "if"
NOT = "not"
OR = "or"
RETURN = "return"
WHILE = "while"

_ = (Whitespace / Comment)*

Whitespace = [ \t\n\r]
Comment = "//"[^\n\r]*
